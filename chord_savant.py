# -*- coding: utf-8 -*-
"""Copy of Chord Savant FINAL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aMqTPZSt7nU0GjQxcVFeyxE0WTYRxfkJ
"""

# !pip install vamp lazycats

import os
from shutil import copy
import pkg_resources
import numpy as np
from scipy.signal import resample
import gdown
import librosa
import vamp
import lazycats.np as catnp
from tensorflow import keras

chroma_vamp_lib = '/home/linuxz/chord_savant/src/chordSavant/res/nnls-chroma.so'
chroma_vamp_key = 'nnls-chroma:nnls-chroma'
model_source = 'https://drive.google.com/uc?id=1XBn7FyYjF8Ff6EuC7PjwwPzFBLRXGP7n'
res_directory = os.path.join(os.path.expanduser('~'), '.chordSavant')
model_directory = os.path.join(res_directory, 'chroma-seq-bilstm-crf-v1')
chord_model = None
sample_rate = 44100
sequence_length = 128
size_of_batch  = 128
size_of_step = 2048 / sample_rate
notes = ['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B']
no_chord = 'No chord'
major_and_minor_chord_classes = [no_chord, *[f'{note}:maj' for note in notes], *[f'{note}:min' for note in notes]]

def chroma_setup():
    vamp_paths = vamp.vampyhost.get_plugin_path()
    vamp_lib_fn = os.path.basename(chroma_vamp_lib)
    for path in vamp_paths:
        try:
            if not os.path.exists(os.path.join(path, vamp_lib_fn)):
                os.makedirs(path, exist_ok = True)
                copy(chroma_vamp_lib, path)

            vamp.vampyhost.load_plugin(chroma_vamp_key, sample_rate, vamp.vampyhost.ADAPT_NONE)
            return

        except Exception as e:
            continue


def model_install():
    os.makedirs(res_directory, exist_ok = True)
    model_zip = os.path.join(res_directory, 'model.zip')
    gdown.download(model_source, model_zip, quiet = False)
    model_files = gdown.extractall(model_zip)
    model_files.sort()
    os.remove(model_zip)
    return model_files[0]


def load_model():
    global model_directory, chord_model
    try:
        if not os.path.exists(model_directory):
            model_directory = model_install()

        chord_model = keras.models.load_model(model_directory)

    except Exception as e:
        raise Exception(f'Error in loading model: {e}')



def chroma_generation(audio_fn, rollon = 1.0):
    samples, fs = librosa.load(audio_fn, sr = None, mono = True)
    if fs != sample_rate:
        samples = resample(samples, num = int(len(samples) * sample_rate / fs))

    out = vamp.collect(samples, sample_rate, 'nnls-chroma:nnls-chroma', output = 'bothchroma', parameters = {'rollon': rollon})

    chroma = out['matrix'][1]
    return chroma


def predicting_labels(chroma_vectors):
    chordseq_vectors = catnp.divide_to_subsequences(chroma_vectors, sub_len = sequence_length)
    pred_labels, _, _, _ = chord_model.predict(chordseq_vectors, batch_size = size_of_batch)
    pred_labels = pred_labels.flatten()
    if len(chroma_vectors) < len(pred_labels):
        pad_st = len(pred_labels) - sequence_length
        pad_ed = pad_st + len(pred_labels) - len(chroma_vectors)
        pred_labels = np.append(pred_labels[:pad_st], pred_labels[pad_ed:])

    assert len(pred_labels) == len(chroma_vectors)
    return pred_labels


def chord_recognition(audio_fn):
    chroma_vectors = chroma_generation(audio_fn)
    pred_labels = predicting_labels(chroma_vectors)

    chord_labels = catnp.squash_consecutive_duplicates(pred_labels)
    chord_lengths = [0] + list(catnp.contiguous_lengths(pred_labels))
    chord_timestamps = np.cumsum(chord_lengths)

    chord_labels = [major_and_minor_chord_classes[label] for label in chord_labels]
    out_labels = [(size_of_step * st, size_of_step * ed, chord_name) for st, ed, chord_name in zip(chord_timestamps[:-1], chord_timestamps[1:], chord_labels)]

    return out_labels


def run_module():
    chroma_setup()
    load_model()

# run_module()

# a = chord_recognition('/content/drive/MyDrive/AERO CHORD - Drop It.mp3')

